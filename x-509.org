:PROPERTIES:
:ID:       6AEEDF1F-BC2D-4D29-99E5-B68050E78994
:ROAM_ALIASES: CA
:END:
#+TITLE: X.509

X.509 是密码学里公钥证书的格式标准，目前如 [[id:DD97CB63-3ED2-4834-A706-D42C9C036FC6][TLS/SSL]] 协议里使用的数字证书就是 X.509 证书，证书含有公钥、身份信息（比如网络主机名，组织的名称或个体名称等）和签名信息（可以是证书签发机构 CA 的签名，也可以是自签名）。

* 数字签名
  在数据传输过程中，我们可以使用[[id:6D2A03A4-EB55-4196-9C38-BE1138045184][消息摘要算法]]计算得到发送的消息的「散列值」，发送消息时将散列值一并发送给目标，目标收到消息后可以使用相同的算法对消息进行摘要，核对得到的散列值是否相同，确保消息没有「损坏」。

  而数字签名则是使用[[id:679FA112-7194-49D4-A766-4E62E06AE072][非对称加密算法]]对「散列值」进行加密得到「加密的散列值」，发送方通过自己的「私钥」加密，接收方通过「公钥」解密，避免消息被中间人攻击篡改。

* 数字证书
  简单来说，数字证书就是一张附带了数字签名的信息表，信息表中含有公钥、身份信息和签名信息，是整个 TLS/SSL 信任体系的基础。

  整个信任体系可以分为三个角色：
  + 认证机构 CA，提供 CA 证书，签发数字证书
  + 服务端，持有 CA 签发的数字证书
  + 客户端，持有 CA 证书

  基本的工作流程为：
  1. CA 基于非对称加密算法生成自己的「公钥」和「私钥」，然后使用私钥自签名得到「根证书」，根证书包含 CA 的公钥、身份信息
  2. 服务端基于非对称加密算法生成自己的公钥和私钥，然后将公钥和自己的身份信息自签名得到「[[id:47E98027-6495-45EF-8EC3-A19B4F54EE2A][证书签名请求]]」后发送给 CA
  3. CA 验证证书签名请求后，结合自己的身份信息签发「数字证书」给服务端
  4. 客户端和服务端交互时：
     1) 客户端根据服务端数字证书上 CA 的身份信息，查找本地对应的 CA 证书
     2) 使用 CA 证书中的公钥解密数字证书的数字签名，比对是否和数字证书上的一致
     3) 一致，说明数字证书有效，否则说明数字证书存在问题

  其中：
  1. CA 证书也是数字证书，只不过是 CA 自己签发的
  2. 客户端需要自己安装授信的 CA 证书，现实中，一些众所周知且被信任证书认证机构的根证书都被内置到了操作系统中
  3. 根 CA 机构可以签发次级 CA 机构的 CA 证书，形成信任链，服务端持有次级数字证书时，同步返回对应的 CA 证书，客户端按照信任链依次验证

* 私有领域
  操作系统内置的自然是公共领域的 CA 证书，而在企业内部，可能也存在私有的 CA 证书，比如 Kubernetes 集群自身就可以作为一个 CA 机构，可以签发集群内使用的数字证书。

* 参考
  + [[https://zhuanlan.zhihu.com/p/36832100][X.509 数字证书的基本原理及应用 - 知乎]]
  + [[https://en.wikipedia.org/wiki/X.509][X.509 - Wikipedia]]
