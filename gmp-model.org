:PROPERTIES:
:ID:       212ED558-0D65-4329-8CCD-7025F6B053D8
:END:
#+TITLE: GMP Model

在使用「多线程 + 任务队列」的模式时，各个线程不断从任务队列中取出任务执行。在这个模式下的问题在于实际的编程中，「任务」常常因为各种 I/O 操作、系统调用阻塞，导致线程跟着阻塞。

此时，任务队列中的任务就会卡住找不到线程来执行。这时可以考虑创建新的线程，但是线程成本高，同时操作系统支持的线程数有限，在高并发场景下就很可能因为线程阻塞无法执行任务。

这种情况下，一个很自然的想法就是能不能把阻塞的任务取出来放到其他地方，等恢复后再加入任务队列，让线程先去执行其他任务？

协程便是实现这个想法的一种实现[fn:1]，甚至协程的历史比多线程的历史还要长，只不过现在重新被拿出来使用了。

假设我们有了协程的实现，现在我们随时可以在协程阻塞时将协程取出来放到另外的地方，然后让线程从任务队列中取新任务来执行：
1. 在这个模型中存在一个全局的任务队列，每个线程都到这个任务队列来获取任务执行
2. 既然是全局对象，那么线程在取任务时就需要获取一个全局的锁，避免 [[id:F0B4E5E0-3457-465B-8062-6A033DA60FF6][race condition]] 的出现
3. 此时每个线程很可能会频繁地获取全局锁，获取任务，带来额外的消耗

[[id:06660642-7CC3-4116-8B42-A43EEB16137F][Golang]] GMP(Goroutine, Thread, Processor) Model 中的 P 便是用于解决这一问题的[fn:2]，P 会关联一个本地队列，M 绑定 P 并从 P 的本地队列中获取任务执行，P 从全局任务队列获取任务放到自己的本地队列。

这种情况下，锁全局队列的频率大大下降了，只在 P 队列空的情况下才会锁全局队列取任务，不同线程也只是去竞争 P，而 P 通常会存在多个，这种情况下锁的粒度也更细。

#+HTML: <img src="https://cdn.learnku.com/uploads/images/202003/11/58489/Ugu3C2WSpM.jpeg%21large">

* 任务窃取
  当 M 绑定的 P 的局部队列为空时，M 会从全局队列获取到本地队列来执行 G，当从全局队列中没有获取到可执行的 G 时候，M 会从其他 P 的局部队列中偷取 G 来执行，这种从其他 P 偷的方式称为 work stealing。

* 阻塞场景
  + 用户态阻塞 ::
    当 goroutine 因为 channel 操作或者 network I/O 而阻塞时（实际上 golang 已经用 netpoller 实现了 goroutine 网络 I/O 阻塞不会导致 M 被阻塞，仅阻塞 G），对应的 G 会被放置到某个 wait 队列(如 channel 的 waitq)，
    该 G 的状态由_Gruning 变为 _Gwaitting，而 M 会跳过该 G 尝试获取并执行下一个 G，如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态。

    当阻塞的 G 被另一端的 G2 唤醒时（比如 channel 的可读/写通知），G 被标记为 runnable，尝试加入 G2 所在 P 的 runnext，然后再是 P 的 Local 队列和 Global 队列。

  + 系统调用阻塞 ::
    当 G 被阻塞在某个系统调用上时，此时 G 会阻塞在 _Gsyscall 状态，M 也处于 block on syscall 状态，此时的 M 可被抢占调度：执行该 G 的 M 会与 P 解绑，而 P 则尝试与其它 idle 的 M 绑定，继续执行其它 G。
    如果没有其它 idle 的 M，但 P 的 Local 队列中仍然有 G 需要执行，则创建一个新的 M；当系统调用完成后，G 会重新尝试获取一个 idle 的 P 进入它的 Local 队列恢复执行，如果没有 idle 的 P，
    G 会被标记为 runnable 加入到 Global 队列。

* 参考
  + [[https://go.cyub.vip/gmp/gmp-model.html][GMP 模型 — 深入 Go 语言之旅]]

* Footnotes
[fn:1] 还有其他的实现，比如 Reactor 模式

[fn:2] 经典的通过加中间层解决问题
