:PROPERTIES:
:ID:       48C679E0-5B26-41C3-8E90-FDC1CA460C32
:END:
#+TITLE: mysql explain

+ Tag :: [[id:CEA916CC-2871-4D97-BC56-E8A414278E52][MySQL]]

MySQL 数据库索引使用的是 B+ 树结构，我们查询数据时，查询条件命中索引时，查询效率会特别高，如果没有命中索引，此时，则会全表扫描，耗时且消耗性能。

通过执行计划，我们可以得知一条 SQL 语句执行下来，这个 SQL 分别查询了哪些表，先查询的哪张表后查询的哪张表，以及是否使用了索引，使用了哪些索引，
当前 SQL 语句查询效率是否高效，这些数据从哪获取到。

通过在 SQL 语句前，添加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询时，会返回执行计划的信息，而不是执行这一条 SQL 语句。

返回的执行计划的信息格式如下：
#+begin_example
  +----+-------------+-------+------------+-------+---------------+---------+---------+--------+------+----------+-------------+
  | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref    | rows | filtered | Extra       |
  +----+-------------+-------+------------+-------+---------------+---------+---------+--------+------+----------+-------------+
  | 1  | SIMPLE      | order | <null>     | index | <null>        | PRIMARY | 8       | <null> | 51   | 100.0    | Using index |
  +----+-------------+-------+------------+-------+---------------+---------+---------+--------+------+----------+-------------+
#+end_example

其中，各字段的含义如下：
+ id：查询 SQL 语句 id，当有多个查询时，将拆分为多个执行计划，每个执行计划都有一个 id，id是 SQL 执行成功的标识，SQL 从大到小的执行，id 越大越先执行。
  当 id 相同的情况时，执行顺序由上至下。
+ select_type：查询类型，MYSQL 中一共有 8 中查询类型，主要作用是用来标记查询类型，比如：普通查询、关联查询、子查询、左查询等
+ table：当前执行计划查询的表，如果给表起别名了，则显示别名信息
+ partitions:：访问的分区表信息
+ type：查询方式，即 MYSQL 如何去查找的表中的行，查询方式是 SQL 优化中一个很重要的指标，结果值从好到坏依次是：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL。
  |--------+--------------------------------------------------------------------------------------------------------------|
  | 类型   | 含义                                                                                                         |
  |--------+--------------------------------------------------------------------------------------------------------------|
  | system | 表中只有一行数据，此时根据索引查询一次就能找到                                                               |
  | const  | SQL 查询时根据索引一次就找到了，此时会显示为 const                                                           |
  | eq_ref | 唯一索引扫描，常见于主键和唯一索引扫描，索引在表中只对应一条记录                                             |
  | ref    | 与 eq_ref 相比，ref 常见于非唯一索引扫描，通常能扫描到多条记录，还可见于唯一索引最左原则匹配扫描也会出现 ref |
  | range  | 通常见于范围扫描，比如：in、大于小于等。索引根据给定范围进行检索                                             |
  | index  | 索引全表扫描，此时扫描只扫描索引树，非数据库表                                                               |
  | All    | 全表扫描                                                                                                     |
  |--------+--------------------------------------------------------------------------------------------------------------|
+ possible_keys：可能使用到的索引
+ key：实际使用到的索引
+ key_len：当前使用的索引的长度
+ ref：关联 id 等信息
+ rows：查找到记录所扫描的行数
+ filtered：查找到所需记录所占总扫描记录数比例
+ Extra：额外的信息

* Rows
  执行计划中 rows 列的值并不准确，特别在语句中存在 Limit 时，返回的 rows 和实际要读取的行数可能存在很大的区别：
  #+begin_src sql
    select id from tbl where id > 100 limit 100;
  #+end_src

  对于上面的 sql 来说，执行计划中返回的 rows 值可能是满足 =id > 100= 条件的行数量，但实际执行时可能只需要读取 100 行。

* Extra
  + =Using index= 表示这次 sql 需要查询的列可以由索引覆盖，不需要回表扫描
  + =Using where= 表示这次 sql 需要根据 where 条件筛选过滤数据

* 参考
  + [[https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_extra][MySQL 8.0 Reference Manual - 8.8.2 EXPLAIN Output Format]]
