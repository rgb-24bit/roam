#+TITLE: article 2021

* 目录                                                    :TOC_4_gh:noexport:
- [[#m01][M01]]
- [[#m02][M02]]
- [[#m03][M03]]
- [[#m04][M04]]
- [[#m05][M05]]
- [[#m06][M06]]
- [[#m07][M07]]

* M01
  ☞ [[https://mp.weixin.qq.com/s/AkCFvCiP7md7pKBN6_8pmw][为什么苹果 M1 芯片如此之快？]]

  1) M1 不是 CPU，它是一个集成了多个芯片的整体系统
  2) 如今摩尔定律已经失效，通过「快速执行更多指令」来提升 CPU 性能已经很难，因此，我们所能做的只能是「并行执行」尽可能多的指令
  3) 并行执行大量指令的方法有两种：
     + 添加更多 CPU 核心，能够让计算机同时执行更多的任务，但是对于单个任务的性能提升有限，适合云服务
     + 通过乱序执行并行执行更多指令
  4) 为什么 AMD 和英特尔的乱序执行不如 M1？（见原文）

  -----

  ☞ [[https://mp.weixin.qq.com/s/yITNjo_UQi8-OKQNOfGrPw][C++ 服务编译耗时优化原理及实践]]

  1) C/C++ 的特点，头文件会在编译时展开，当大的头文件被频繁引用时，编译时长自然会增加很多。基于这一点，通过工具分析头文件的依赖关系，
     去掉不合理的部分，可以起到优化编译耗时的作用

  -----

  ☞ [[https://www.infoq.cn/article/Ov7prhrTiNw6JjhELmh6][4 种主流的 API 架构风格对比-InfoQ]]

  1) 四种 API 架构中接触的较多的是 RESTful 和 RPC，一个对外，一个对内
  2) GraphQL 有过了解，但没有使用过
  3) SOAP 似乎看到过，还以为这种结构都废弃了，但还是有其使用场景
  4) 每种架构都有其适合的场景，不能太过绝对的认为某一个架构由于另一个，同时，业界今年来的飞速发展，新的技术不断出现，
     只能说新的技术有其更适合的特化场景，不能说老技术就没价值了。

     根据业务场景选择适合的技术栈，而不是一味的追求新。

  -----

  ☞ [[https://blog.betacat.io/post/2020/03/a-pattern-for-writing-testable-go-code/][编写可测试 Go 代码的一种模式 - 喵叔没话说]]

  1) Go 语言的特性，或者说风格在部分场景下对于单测并不友好，这时如果一定要追求 100% 的覆盖率，那么，就不得不通过一些手段来替换自己的代码。

     这样的代码很丑，完全为了单测而编写的代码，比如需要测试的代码中存在 package.Func 时。

     另外，代码中存在 if err 也为编写单测带来了巨大的负担。

  2) Go Code Review 就指明了，Go 推荐在需要使用的地方定义接口，而不是先定义接口再去实现。

     Go 接口的实现和结构体的定义是割裂的，在只看到结构体的情况下你并不能知道它实现了什么接口，这时如果还遵循 Java 里面先接口后实现的模式，
     在代码量上来后，反而会为代码的维护和阅读带来额外的负担。

  -----

  ☞ [[https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md][Sizedness in Rust]]

  1) double-width pointer，同时存在指向对象的指针和指向长度的指针

* M02
  ☞ [[https://help.aliyun.com/document_detail/164859.html][自动 SQL 限流 - 数据库自治服务 DAS - 阿里云]]

  1) 对异常 SQL 类型的分类很有道理：
     + 阻塞型 SQL，通过分析实时会话、锁等待和运行中的事务，判断是否存在 DDL 变更、锁等待和大事务等情况。同时分析和判断被影响会话的数量和执行时间，如果被影响的会话比较多或执行时间很长，
       则该异常无需通过限流 SQL 来解决，而是 Kill 异常会话。
     + 资源消耗型 SQL（即烂 SQL），可能 SQL 的并发量不大，但会消耗大量的 CPU、IO 或网络资源，并且会持续不断地提交
     + 流量型 SQL，大量的正常 SQL 在数据库中同时运行，触发数据库的资源瓶颈，导致甚至 KV 类的查询 SQL 的响应时间都出现异常
     + 其他，其他未包含上述 3 种情况的场景
  2) SQL 的特征提取：
     + SQL 模板，将 SQL 文本的具体参数抽象化后的文本。这类 SQL 并发度高都会产生问题，但与具体参数无关，因此特征只需要包含模板特征即可，就是相当于对应的 prepare sql
     + SQL 文本，同一类模板中一些 SQL 执行正常，但另一些执行异常，特征中既要包含 SQL 模板信息，又要包含具体参数信息

  -----

  ☞ [[https://mp.weixin.qq.com/s/k9r7XtAq7VnAvyZ2G5Kdgg][你不好奇 CPU 是如何执行任务的？]]

  1) 从 CPU 缓存到 Disk 读取，随机访问延迟从 1ns 到 10ms，也就是说 Disk 读取一次够 CPU 在 L1 Cache 中读取 10_000_000 次了，差了 7 个数量级，
     难怪说异步架构能够提高程序性能，避免 I/O 阻塞，提高 CPU 利用率是很大的提升了。
  2) 多核系统中 Cache Line 大小和实际变量大小的不同可能导致的伪共享问题，之前只知道结构体数据对齐，现在看来，在多核环境下，仅仅是数据宽度对齐可能还不够，
     还需要 Cache Line Size 对齐才能最有效的利用 CPU 缓存。

* M03
  ☞ [[https://tech.meituan.com/2020/02/27/meituan-waimai-micro-frontends-practice.html][微前端在美团外卖的实践 - 美团技术团队]]

  1) 这边文章是在了解到「微前端」这个陌生的概念后 Google 出来的，因为写过一点前端代码，所以对这些东西的原理还是比较好奇。
  2) 从这篇文章中的东西来看，「微前端」本质上就是利用一个中心化的基座来维护通用的能力，利用路由来匹配子系统，在用户进入相关的子路由后，
     就加载相关子系统代码到前端。
  3) 和「微服务」的模式是比较像的，中心化的基座起到服务发现的作用，而路由对应就是服务名称
  4) 由于前端模式比较特殊，虽然利用「微前端」的模式对不同子系统进行了拆分，单本质上最后所有系统的代码还是会加载到一个页面，因此，
     需要考虑如何解决不同系统代码间代码冲突的问题。即实现一个前端的沙箱，文章 [[https://segmentfault.com/a/1190000038219823][解密微前端：从 qiankun 看沙箱隔离]] 对这个概念有简单的解析。

  -----

  ☞ [[https://draveness.me//whys-the-design-cpu-and-disk][为什么 CPU 访问硬盘很慢 - 面向信仰编程]]

  1) CPU 需要通过 I/O 操作访问外部存储中的数据，编程 I/O、中断驱动 I/O 和 DMA 几种方式都会带来额外开销并占用较多的 CPU 时间
  2) 机械硬盘会通过机械结构访问其中存储的数据，每一次硬盘的随机 I/O 都需要执行队列、寻道、旋转和转移数据几个过程，大约需要消耗 10ms 的时间
  3) 10ms 看似很少，但是通过前面的文章我们已经可以知道，这已经够 CPU 执行 10_000_000 次了，因此，如何避免 I/O 带来的阻塞是提高服务性能的关键点

  -----

  ☞ [[https://draveness.me//whys-the-design-syscall-overhead][为什么系统调用会消耗较多资源 - 面向信仰编程]]

  1) 在 《深入理解计算机系统》这本书里面就有介绍「中断」的概念，利用中断来实现的系统调用是一个较为复杂的调用流程，会执行很多额外的操作，
     不可避免的需要比普通函数消耗更多的时间
  2) vDSO 可以将 Linux 内核中不涉及安全的系统调用直接映射到用户空间，这样用户空间中的应用程序在调用这些函数时就不需要切换到内核态以减少性能上的损失
  3) 虽然经常可以看到内核态和用户态的概念，但是对它们的了解并不是很深，可以去了解一下

  -----

  ☞ [[https://tailscale.com/blog/netaddr-new-ip-type-for-go/][netaddr.IP: a new IP address type for Go · Tailscale Blog]]

  1) 这篇博客的阅读体验很好，一步一步为你解释清楚了为什么，目标是怎样的，如何实现
  2) Take 3 开始代码的复杂度直线上升，阅读很多这类代码的时候都有这种感觉，出于优化的需要，代码的复杂度都会有很大的增加，而且直接看代码有可能还看不出来为什么这样做
  3) 有时，为了避免思路的打乱，变量的命名都会变得很简略，可能就是某个单词的首字母

  -----

  ☞ [[https://mp.weixin.qq.com/s/-op5WR1wSkgAuP7JYZWP8g][Redis 多线程网络模型全面揭秘]]

  1) 听同事说过的一句话：高性能 = 异步 + 缓存，现在业界感觉多线程已经不能满足高并发的需求了，需要多线程 + 协程的方式，使用协程进一步降低线程切换的消耗，
     结合异步 I/O，尽可能地利用 CPU 的性能
  2) Redis 过去的单线程模型到 6.0 之后的多线程模型，主要目的还是希望将 I/O 操作相关的时间放到其他线程，减少在主线程上占用的 CPU 时间，提高效率
  3) 同时，Redis 是一个内存数据库，因此，主线程执行命令时的 I/O 时间相较于 MySQL 少很多很多，保持简单的情况下完全可以接收

  -----

  ☞ [[https://www.infoq.cn/article/Bb2YC0yHVSz4qVwdgZmO][缓存踩踏：Facebook史上最严重的宕机事件分析-InfoQ]]

  1) 缓存踩踏的概念还是第一次见，好像就是缓存击穿？MD，名词是真的多……
  2) 锁是很常见的做法，但是 Promise 还是第一次见，感觉很有启发性
  3) 预先重计算感觉确实是一个不错的方案，甚至公式都有了，啥时候感觉可以试试

* M04
  ☞ [[https://www.cnblogs.com/jiujuan/p/13869547.html][TCMalloc 内存分配原理简析 - 九卷 - 博客园]]

  1) 本来是看到 Golang 内存管理相关的文章，结果被这篇参考文章吸引了_(:з」∠)_
  2) 面试中经常会问内存回收相关的问题，但内存分配的好像比较少
  3) 感觉并发场景下内存的分配、访问和回收的基本思路貌似都差不多？这里的 per core cache > mid cache => backend 和 CPU 高速缓存结构也比较类似

  -----

  ☞ [[https://mp.weixin.qq.com/s/ZA-_BARVAWe0Q4eM0lYgwg][透过 Rust 探索系统的本原：编程语言]]

  1) 一般而言，一门语言在设计之初，总需要在：性能（performance），安全（safety）和表达力（expressiveness）上做取舍
  2) Rust 刚开始学，感受上确实和之前学习过的语言不一样，在提供了 C/C++ Level 级别的性能，Python 级别的抽象能力的同时，保证了类型安全。
     但相应的，这需要 Rust 强大的编译器提供支持，而 Rust 也将很多语言层面的细节暴露出来，编写代码的时候需要考虑这样写是否能通过编译。
     这和其他语言中只需要简单关注是否符合语法不一样。
  3) 后面感觉可以学习一下 Erlang/Elixir/Sala，对 actor model 还是有点好奇的

  -----

  ☞ [[https://www.infoq.cn/article/t0qlhfk7uxxzwo0uo*9s][Feed 流系统设计总纲-InfoQ]]

  1) 推模式/拉模式 - 读写扩散，看到这篇文章才猛然发现，现在业界不少场景已经有较为成熟的解决方案，比如这里的 Feed 流，
     可以去了解这些业界常见问题及解决方案

* M05
  ☞ [[https://blog.csdn.net/csdnnews/article/details/116148753][分布式数据库进入实时时代，TiDB 5.0 带来了什么？_CSDN资讯-CSDN博客_分布式数据库 开源]]

  1) 之前听过一次 TiDB 分享，能够感受到 TiDB 的设计思路一开始就考虑了分布式场景
  2) 时代在发展，处于不同的时代，面临的问题也就不同，过去的设计需要应用到现在的场景，往往就需要进行一些修改和妥协
  3) 不知道什么时候能在工作中体验一把 TiDB

  -----

  ☞ [[https://mp.weixin.qq.com/s/Qdsm1RWQ0xGp4GwhmI_t8g][Google 和 Facebook 为什么不用 Git 管理源码？]]

  1) Git 是我经常使用也是目前唯一会使用的版本控制工具，之前同时也对 Subversion 很鄙视，觉得为什么会有公司用这样的工具
  2) 但是通过这篇文章发现，文章中的一些例子用 Git 来实现的话确实很难，或者说无法实现
  3) 从 Git 到 GitHub，Git 适合开源的协作模式，但不一定适合其他模式，Subversion 这些工具或许不适合来源场景，
     但也有适合的场景，不应该随便鄙视
  4) 还是应该根据应用场景来判断优劣
     
* M06
  ☞ [[https://www.infoq.cn/news/DbZAsZugmkIbqSxZ09RU][终于！Fuchsia OS正式公开可用，谷歌迈出了五年来最关键的一步-InfoQ]]

  1) Fuchsia 主要面向采用“高速处理器”加“低内存容量”的“现代手机与个人计算机平台”
  2) 确实，不同系统的设计面对的场景是不一样的，虽然迁移到另一个场景也许可以使用，但不一定是最适合的
  3) 工具的选择也是这个道理，有的工具在某些场景下也许很好用，但要强行用于其他场景，可不可以用是一回事，好不好用是另外一回事

* M07
  ☞ [[https://codahale.com/how-to-safely-store-a-password/][How To Safely Store A Password | codahale.com]]

  + 自己之前使用的其实还是 sha256 + salt……

