:PROPERTIES:
:ID:       D9857BCF-90F8-4CFC-ABD5-D7D5BD4E56DC
:END:
#+TITLE: Linux Virtual Network Device

* veth pair
  veth pair 可以理解为通过网线连接的两个网卡，两端都连接着[[id:25BD4E54-52A7-45B8-A256-24C3AD801D05][协议栈]]，从一端流入的数据会从对应的另一端流出：
  #+begin_example
    +----------------------------------------------------------------+
    |                                                                |
    |       +------------------------------------------------+       |
    |       |             Newwork Protocol Stack             |       |
    |       +------------------------------------------------+       |
    |              ↑               ↑               ↑                 |
    |..............|...............|...............|.................|
    |              ↓               ↓               ↓                 |
    |        +----------+    +-----------+   +-----------+           |
    |        |   eth0   |    |   veth0   |   |   veth1   |           |
    |        +----------+    +-----------+   +-----------+           |
    |192.168.1.11  ↑               ↑               ↑                 |
    |              |               +---------------+                 |
    |              |         192.168.2.11     192.168.2.1            |
    +--------------|-------------------------------------------------+
                   ↓
             Physical Network
  #+end_example

  创建：
  #+begin_example
    $ sudo ip link add veth0 type veth peer name veth1
  #+end_example

  可以将 veth pair 放在不同的 [[id:1FCC1385-CCFD-40E3-9B49-AC1151C49B9F][linux namespace]] 中，这样可以实现不同 namespace 网络的互通。

  参考：[[https://segmentfault.com/a/1190000009251098][Linux 虚拟网络设备之 veth - SegmentFault 思否]]

* tun/tap
  tun/tap 设备是 VPN 常用的实现手段，通常一个 tun/tap 设备存在一个对应的用户态程序，发向 tun/tap 设备的数据会转发到用户态程序，由程序处理后在转发到物理网络：
  #+begin_example
    +----------------------------------------------------------------+
    |                                                                |
    |  +--------------------+      +--------------------+            |
    |  | User Application A |      | User Application B |<-----+     |
    |  +--------------------+      +--------------------+      |     |
    |               | 1                    | 5                 |     |
    |...............|......................|...................|.....|
    |               ↓                      ↓                   |     |
    |         +----------+           +----------+              |     |
    |         | socket A |           | socket B |              |     |
    |         +----------+           +----------+              |     |
    |                 | 2               | 6                    |     |
    |.................|.................|......................|.....|
    |                 ↓                 ↓                      |     |
    |             +------------------------+                 4 |     |
    |             | Newwork Protocol Stack |                   |     |
    |             +------------------------+                   |     |
    |                | 7                 | 3                   |     |
    |................|...................|.....................|.....|
    |                ↓                   ↓                     |     |
    |        +----------------+    +----------------+          |     |
    |        |      eth0      |    |      tun0      |          |     |
    |        +----------------+    +----------------+          |     |
    |    10.32.0.11  |                   |   192.168.3.11      |     |
    |                | 8                 +---------------------+     |
    |                |                                               |
    +----------------|-----------------------------------------------+
                     ↓
             Physical Network
  #+end_example

  其中，tun/tap 是两类设备的合称，工作流程一样，只不过分别工作在不同层，tun 工作在三层（IP），而 tap 工作在二层（MAC）。

  参考：[[https://segmentfault.com/a/1190000009249039][Linux 虚拟网络设备之 tun/tap - SegmentFault 思否]]

* bridge
  可以将 bridge 理解为一个纯软件实现的交换机，在具有交换机功能的情况下也可以配置 MAC、IP 地址，可以当作虚拟的网卡使用，连接到 bridge 的设备，从设备流向[[id:25BD4E54-52A7-45B8-A256-24C3AD801D05][协议栈]]的数据会转到 bridge，即：
  + 当设备连接到 bridge 后，设备和协议栈的双向连接被打断，连接「协议栈 -> 设备」依然存在，但是「设备 -> 协议栈」被替换为了「设备 -> bridge」
  + 如果设备没有 IP 地址，那么连接「协议栈 -> 设备」也可以看着不存在，因为系统路由不会选择这个设备了
  + 同时存在「bridge -> 设备」的连接，也就是 bridge 和连接到它的设备存在双向连接

  bridge 根据 MAC 地址判断数据转发到哪个端口，新建的 bridge 默认只连接了协议栈，不具备其他功能：
  #+begin_example
    $ sudo ip link add name br0 type bridge
    $ sudo ip link set br0 up

    +----------------------------------------------------------------+
    |                                                                |
    |       +------------------------------------------------+       |
    |       |             Newwork Protocol Stack             |       |
    |       +------------------------------------------------+       |
    |              ↑                                ↑                |
    |..............|................................|................|
    |              ↓                                ↓                |
    |        +----------+                     +------------+         |
    |        |   eth0   |                     |     br0    |         |
    |        +----------+                     +------------+         |
    | 192.168.3.21 ↑                                                 |
    |              |                                                 |
    |              |                                                 |
    +--------------|-------------------------------------------------+
                   ↓
             Physical Network
  #+end_example

  可以创建 veth pair 设备并连接到 bridge 上，veth 默认是和协议栈存在双向链接的，但是连到 bridge 上后 veth 到协议栈的连接就被 bridge 拦了：
  #+begin_example
    $ sudo ip link add veth0 type veth peer name veth1
    $ sudo ip addr add 192.168.3.101/24 dev veth0
    $ sudo ip addr add 192.168.3.102/24 dev veth1
    $ sudo ip link set veth0 up
    $ sudo ip link set veth1 up
    $ sudo ip link set dev veth0 master br0

    +----------------------------------------------------------------+
    |                                                                |
    |       +------------------------------------------------+       |
    |       |             Newwork Protocol Stack             |       |
    |       +------------------------------------------------+       |
    |            ↑            ↑              |            ↑          |
    |............|............|..............|............|..........|
    |            ↓            ↓              ↓            ↓          |
    |        +------+     +--------+     +-------+    +-------+      |
    |        | .3.21|     |        |     | .3.101|    | .3.102|      |
    |        +------+     +--------+     +-------+    +-------+      |
    |        | eth0 |     |   br0  |<--->| veth0 |    | veth1 |      |
    |        +------+     +--------+     +-------+    +-------+      |
    |            ↑                           ↑            ↑          |
    |            |                           |            |          |
    |            |                           +------------+          |
    |            |                                                   |
    +------------|---------------------------------------------------+
                 ↓
         Physical Network
  #+end_example

  此时连接「veth0 -> 协议栈」断开，这样流向 veth0 的数据就无法被协议栈接收了，直接的效果就是 veth0 发出 arp 请求后应答帧返回给 veth0 后会交给 br0，
  而协议栈就无法知道 ip 对应的 mac 地址。

  PS：实验的时候，如果有 arp 缓存好像还是 ok 的，有 arp 缓存时 ICMP 请求直接从协议栈 -> veth0，然后 veth0 交给 veth1（出流量不会到 br0），这时 veth1 可以应答，
  就是不知道为啥 veth0 协议栈能够收到 ICMP 应答。

  如果删除 veth0 的 ip 地址，那么协议栈就不会往 veth0 发送数据了，这样 veth0 和协议栈之间的连接就没有了：
  #+begin_example
    +----------------------------------------------------------------+
    |                                                                |
    |       +------------------------------------------------+       |
    |       |             Newwork Protocol Stack             |       |
    |       +------------------------------------------------+       |
    |            ↑            ↑                           ↑          |
    |............|............|...........................|..........|
    |            ↓            ↓                           ↓          |
    |        +------+     +--------+     +-------+    +-------+      |
    |        | .3.21|     | .3.101 |     |       |    | .3.102|      |
    |        +------+     +--------+     +-------+    +-------+      |
    |        | eth0 |     |   br0  |<--->| veth0 |    | veth1 |      |
    |        +------+     +--------+     +-------+    +-------+      |
    |            ↑                           ↑            ↑          |
    |            |                           |            |          |
    |            |                           +------------+          |
    |            |                                                   |
    +------------|---------------------------------------------------+
                 ↓
         Physical Network
  #+end_example

  类似的，可以将物理网卡 eth0 连接到 br0，同时删除 eth0 的 ip，这样 eth0 会和协议栈断开连接，变成连接 bridge 和物理网络的网线：
  #+begin_example
    +----------------------------------------------------------------+
    |                                                                |
    |       +------------------------------------------------+       |
    |       |             Newwork Protocol Stack             |       |
    |       +------------------------------------------------+       |
    |                                                     ↑          |
    |.....................................................|..........|
    |                                                     ↓          |
    |        +------+     +--------+     +-------+    +-------+      |
    |        |      |     |        |     |       |    | .3.102|      |
    |        +------+     +--------+     +-------+    +-------+      |
    |        | eth0 |<--->|   br0  |<--->| veth0 |    | veth1 |      |
    |        +------+     +--------+     +-------+    +-------+      |
    |            ↑                           ↑            ↑          |
    |            |                           |            |          |
    |            |                           +------------+          |
    |            |                                                   |
    +------------|---------------------------------------------------+
                 ↓
         Physical Network
  #+end_example

  PS：
  1. 如果是在虚拟机上做上述操作，需要打开网卡的混杂模式[fn:1]，不然 veth1 的网络会不通，因为 eth0 不在混杂模式的话，会丢掉目的 mac 地址是 veth1 的数据包
  2. 上述操作在 debian8 可以复现，debian9 无法复现，其他系统好像也不行，好像和内核参数有关

  #+begin_comment
  关于 veth1 到 gateway 流向的猜测：
  1. veth1 发起 arp 广播，br0 将 arp 广播转发到 eth0，eth0 直接转发到物理网络（猜测）
  2. 物理网络上的 gateway 响应 arp 广播，经由 eth0 -> br0 -> veth0 -> veth1 的路线返回，此时 br0 记录 <eth0 端口> mac 地址为 gateway 地址

  主要是猜测，不清楚 eth0 没有连接协议栈时的工作方式，有点像 br0 通过 eth0 连到物理网络的交换机？
  #+end_comment

  对于容器来说，采用了另一种方式来和外界通信：
  #+begin_example
    +----------------------------------------------------------------+-----------------------------------------+-----------------------------------------+
    |                          Host                                  |              Container 1                |              Container 2                |
    |                                                                |                                         |                                         |
    |       +------------------------------------------------+       |       +-------------------------+       |       +-------------------------+       |
    |       |             Newwork Protocol Stack             |       |       |  Newwork Protocol Stack |       |       |  Newwork Protocol Stack |       |
    |       +------------------------------------------------+       |       +-------------------------+       |       +-------------------------+       |
    |            ↑             ↑                                     |                   ↑                     |                    ↑                    |
    |............|.............|.....................................|...................|.....................|....................|....................|
    |            ↓             ↓                                     |                   ↓                     |                    ↓                    |
    |        +------+     +--------+                                 |               +-------+                 |                +-------+                |
    |        |.3.101|     |  .9.1  |                                 |               |  .9.2 |                 |                |  .9.3 |                |
    |        +------+     +--------+     +-------+                   |               +-------+                 |                +-------+                |
    |        | eth0 |     |   br0  |<--->|  veth |                   |               | eth0  |                 |                | eth0  |                |
    |        +------+     +--------+     +-------+                   |               +-------+                 |                +-------+                |
    |            ↑             ↑             ↑                       |                   ↑                     |                    ↑                    |
    |            |             |             +-------------------------------------------+                     |                    |                    |
    |            |             ↓                                     |                                         |                    |                    |
    |            |         +-------+                                 |                                         |                    |                    |
    |            |         |  veth |                                 |                                         |                    |                    |
    |            |         +-------+                                 |                                         |                    |                    |
    |            |             ↑                                     |                                         |                    |                    |
    |            |             +-------------------------------------------------------------------------------|--------------------+                    |
    |            |                                                   |                                         |                                         |
    |            |                                                   |                                         |                                         |
    |            |                                                   |                                         |                                         |
    +------------|---------------------------------------------------+-----------------------------------------+-----------------------------------------+
                 ↓
         Physical Network  (192.168.3.0/24)
  #+end_example

  容器中发出去的数据包先到达 br0，然后交给 host 机器的协议栈，由于目的 IP 是外网 IP，且 host 机器开启了 [[id:9E06B2E6-4ACB-4C23-9FB6-1DA55C747804][IP forward]] 功能，于是数据包会通过 eth0 发送出去。

  参考：[[https://segmentfault.com/a/1190000009491002][Linux 虚拟网络设备之 bridge(桥) - SegmentFault 思否]]

* Footnotes

[fn:1] 工作在混杂模式下的网卡接收所有的流过网卡的帧，包括不是发给本机的包，即不验证 MAC 地址
