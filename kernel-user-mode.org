:PROPERTIES:
:ID:       F949C433-98B6-4AD5-BCFB-AF2C1459D497
:END:
#+TITLE: kernel user mode

* 切换消耗
  用户态切换到内核态时的消耗：
  1. 系统调用通常会有对应的包装函数，用户首先调用包装函数（常规函数调用开销）
  2. 调用参数通过栈传递给包装函数，这些参数会被内核拷贝到寄存器，供系统调用使用（额外开销）
  3. 系统调用有单独的唯一数字标识，内核将系统调用对应的数字标识存入特定寄存器（额外开销）
  4. 包装函数执行 (int 0x80) 使处理器从用户态切换到内核态，并执行对应的缺陷函数（额外开销）
  5. 内核开始系统调用执行流程：
     1. 保存寄存器中的参数到内核栈
     2. 根据系统调用的数字标识查表找到对应的系统调用代码
     3. 执行
     4. 从内核栈恢复寄存器的值，并将调用结果放入栈中
     5. 返回到包装函数，处理器恢复用户态
  6. ……
     
  可以看错用户态和内核态就是两个进程通过寄存器、处理器缺陷调用来进行交互，比常规函数的执行会多出很多的额外消耗，
  如果频繁执行切换，就会带来不小的性能损耗。
  
  参考：[[https://www.quora.com/Why-it-is-expensive-to-switch-from-user-mode-to-kernel-mode][Why it is expensive to switch from user-mode to kernel-mode? - Quora]]

* CPU 指令集权限
  CPU 指令集有权限分级，其中高权限的指令集主要包括操作外部设备的指令，比如硬盘、鼠标、显示器啥的，这些设备的操作权限通常就对应到内核态，内核将这些设备的操作能力做好封装提供给用户态使用。

  也就是：
  + 内核态具有高 CPU 指令集权限，能够执行所有操作
  + 用户态具有低 CPU 指令集权限，能够执行有限的操作，并使用内核提供的系统调用来安全操作外部设备

