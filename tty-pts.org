:PROPERTIES:
:ID:       F12B6144-DE9C-473A-9837-69782AF63E19
:END:
#+TITLE: Linux TTY/PTS

在早期多任务的计算机刚出现时，人们使用不同的 teletype 连接到计算机上，UART 将 teletype 的信号转换成计算机能识别的信号：
#+begin_example
                                                                        +----------+ 
  +----------+   +-------+     Physical Line     +-------+   +------+   |          |
  | Terminal |<->| Modem |<--------------------->| Modem |<->| UART |<->| Computer |
  +----------+   +-------+                       +-------+   +------+   |          |
                                                                        +----------+
#+end_example

计算机为了支持这些 teletype，于是设计了名字叫做 TTY 的子系统，内部结构如下：
#+begin_example
      +-----------------------------------------------+
      |                    Kernel                     |
      |                                 +--------+    |
      |   +--------+   +------------+   |        |    |       +----------------+
      |   |  UART  |   |    Line    |   |  TTY   |<---------->| User process A |
  <------>|        |<->|            |<->|        |    |       +----------------+
      |   | driver |   | discipline |   | driver |<---------->| User process B |
      |   +--------+   +------------+   |        |    |       +----------------+
      |                                 +--------+    |
      |                                               |
      +-----------------------------------------------+
#+end_example

各部分：
+ UART driver 对接外面的 UART 设备
+ Line discipline 主要是对输入和输出做一些处理，可以理解它是 TTY driver 的一部分
+ TTY driver 用来处理各种终端设备
+ 用户空间的进程通过 TTY driver 来和终端打交道

而在现在，已经不需要那么多的 teletype，直接键鼠直接就行了，但内核的这套 TTY 系统还是保留了下来。

使用键鼠直连时，内核中的 Terminal Emulator 负责创建虚拟的 TTY 设备：
#+begin_example
                     +-----------------------------------------+
                     |          Kernel                         |
                     |                           +--------+    |       +----------------+ 
   +----------+      |   +-------------------+   |  tty1  |<---------->| User processes |
   | Keyboard |--------->|                   |   +--------+    |       +----------------+
   +----------+      |   | Terminal Emulator |<->|  tty2  |<---------->| User processes |
   | Monitor  |<---------|                   |   +--------+    |       +----------------+
   +----------+      |   +-------------------+   |  tty3  |<---------->| User processes |
                     |                           +--------+    |       +----------------+
                     |                                         |
                     +-----------------------------------------+
#+end_example

使用终端模拟器，如 iTerm 时使用 ptmx 创建 pts 伪终端：
#+begin_example
   +----------+       +------------+
   | Keyboard |------>|            |
   +----------+       |  Terminal  |--------------------------+
   | Monitor  |<------|            |           fork           |
   +----------+       +------------+                          |
                          |   ↑                               |
                          |   |                               |
                    write |   | read                          |
                          |   |                               |
                    +-----|---|-------------------+           |
                    |     |   |                   |           ↓
                    |     ↓   |      +-------+    |       +-------+
                    |   +--------+   | pts/0 |<---------->| shell |
                    |   |        |   +-------+    |       +-------+
                    |   |  ptmx  |<->| pts/1 |<---------->| shell |
                    |   |        |   +-------+    |       +-------+
                    |   +--------+   | pts/2 |<---------->| shell |
                    |                +-------+    |       +-------+
                    |    Kernel                   |
                    +-----------------------------+
#+end_example

而我们现在通常使用的各种终端模拟器、WebShell 便是基于 ptmx 实现，设置终端参数，转发 I/O 流等。

参考：
+ [[https://segmentfault.com/a/1190000009082089][Linux TTY/PTS 概述 - Linux 程序员 - SegmentFault 思否]]

